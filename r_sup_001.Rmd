---
title: "vs_sup"
author: "drsimonturega"
date: "2025-12-16"
output:
  html_document: default
  pdf_document: default
---

```{r include=FALSE}
library(tidyverse)
#install.packages("reshape2")
library(reshape2)
library(ggplot2)
# You may have to instal tinytex
#tinytex::install_tinytex()
```

# Virtual screening for high affinity guests for synthetic supramolecular receptors

### Orginal literature

<https://doi.org/10.1039/C5SC00534E>

### Function used in this analysis
I don't have a R data science package(library) yet... 
```{r my_functions, echo=FALSE}

get_column_value <- function(d_frame, d_col) {
  # Use get() to retrieve the column by its string name
  # expand to use d_cal being a list
  get(d_col, d_frame)
}


hist_ylims <- function(dens){
  # Get y axis limits for a column from a data frame
  #data = get_column_value(d_frame, d_col)
  ylim = c(min(dens$y), c(max(dens$y)))
  return(ylim)
  }

int_made_even<- function(num){
  # make an int even
  if((num %% 2) != 0) 
    return(num+1)
  else
    return(num)
 }
  

hist_kde <- function(d_frame, d_col){
  # Colored Histogram with KDE line for clarity
  data  = get_column_value(d_frame, d_col )
  dens <- density(data)
  hist(data, main=d_col, xlab = d_col, ylim = (hist_ylims(dens)), col="blue", freq = FALSE)
  lines(dens, lwd = 2,  col = "black")
}

q_q_plot <- function(d_frame, d_col){
  # Generate a quartile quartile plot
  data  = get_column_value(d_frame, d_col )
  qqnorm(data, main = d_col,  pch = 1)
  qqline(data, col = "blue", lwd = 2)
}

multi_plot <- function(d_frame,plot_t){
 # multi plot 
  n_col = ncol(d_frame)
  n_plot = int_made_even(n_col)
  col_names = colnames(d_frame)
  # make plots
  par(mfrow=c(2,(n_plot/2) ))
  for (col in col_names)
    plot_t(d_frame, col)
}

get_upper_tri <- function(mat){
  # split correlation matrix in have retain upper half
  mat[lower.tri(mat)]<- NA
  return(mat)
  }

get_lower_tri <- function(mat){
  # split correlation matrix in have retain upper half
  mat[upper.tri(mat)]<- NA
  return(mat)
}

reorder_cormat <- function(mat){
  # Use correlation between variables as distance
  dd <- as.dist((1-mat)/2)
  hc <- hclust(dd)
  mat <-mat[hc$order, hc$order]
  return(mat)
}

correl_mat_plot <- function(mat, title){
  mat = round(cor(mat),2)
  mat = get_upper_tri(mat)
  mat = melt(mat, na.rm = TRUE)
  ggplot(data = mat, aes(x = Var2, y = Var1, fill = value))+
    geom_tile(color = "white")+
    scale_fill_gradient2(low = "darkblue", high = "lightblue", mid = "white", 
      midpoint = 0, limit = c(-1,1), space = "Lab", 
      name="Pearson\nCorrelation") +
     theme_minimal()+
    #geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1,
      size = 12, hjust = 1)) +
    theme(
      axis.title.x = element_blank(),
      axis.title.y = element_blank()) +
    ggtitle(title) +
    theme(plot.title = element_text(hjust = 0.5)) +
    coord_fixed()
}

correl_mat_plot_2 <- function(mat, title){
  mat = round(cor(mat),2)
  mat = get_upper_tri(mat)
  mat = melt(mat, na.rm = TRUE)
  mat = reorder_cormat(mat)
  ggplot(data = mat, aes(x = Var2, y = Var1, fill = value))+
    geom_tile(color = "white")+
    scale_fill_gradient2(low = "darkblue", high = "lightblue", mid = "white", 
      midpoint = 0, limit = c(-1,1), space = "Lab", 
      name="Pearson\nCorrelation") +
     theme_minimal()+
    geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1,
      size = 12, hjust = 1),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      panel.grid.major = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank(),
      axis.ticks = element_blank(),
      legend.justification = c(1, 0),
      legend.position = c(0.6, 0.7),
      legend.direction = "horizontal")+
      guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                title.position = "top", title.hjust = 0.5))+
    geom_tile() +
    ggtitle(title) +
    coord_fixed()
}

  
```

## Replication of our analysis in the manuscript using python


### We load cleaned data from the supporting information

```{r load datata science style df}
df = read.csv("tab_gold_wt.csv", header = TRUE)
```

## Run some exploratory data analysis

### Data summary

```{r }
summary(df)
```
 we still have guest number the data frame we will remove it
 

 
```{r}
 df <- df[-c(1)]
 summary(df)
```


### Histogram with KDE line for clarity
The histogram is in blue bars. The Kernel Density Estimation line is and estimation of the histogram represented as a continuous line and is shown as a black line.
```{r }

hist_kde(df, "Part_buried")
```
Its helpful to plot all dataframe columns
```{r }
multi_plot(df, hist_kde)
```

### Quantile quantile plots
Our quantile quantile plots show us weather our data fits to a theoretical distribution 
```{r multi-plot quantile quantile }
multi_plot(df, q_q_plot)

```

This is experimental data from 69 individual data points our team generated, so we don't really expect it to fit a normal distribution. We would expect the replicates of **logKexp** to fit a normal distribution and the error quoted in the manuscript is at 95% confidence.

### Correlation matrix heatmap
Over correlated molecular descriptor (GoldPLP functions)  columns can cause problems with our regression models. Too many correlated models cause a misrepresentation of those molecular descriptors in our regression model.
```{r preparing the data}
cor_mat <- round(cor(df),2)
head(cor_mat)
```
Reshape our dataframe
```{r reshape data}
melted_cor_mat <- melt(cor_mat)
head(melted_cor_mat)
```
```{r corr heatmap}
ggplot(data = melted_cor_mat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  ggtitle("Correlation plot for functions from GoldPLP") +
  theme(plot.title = element_text(hjust = 0.5))
```

```{r neater correlatio matrix}
correl_mat_plot(df, "Correlation plot for functions from GoldPLP")
```
